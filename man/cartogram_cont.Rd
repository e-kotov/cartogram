% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cartogram_cont.R
\name{cartogram_cont}
\alias{cartogram_cont}
\alias{cartogram_cont.SpatialPolygonsDataFrame}
\alias{cartogram_cont.sf}
\title{Calculate Contiguous Cartogram Boundaries}
\usage{
cartogram_cont(
  x,
  weight,
  itermax = 15,
  maxSizeError = 1.0001,
  prepare = "adjust",
  threshold = "auto",
  verbose = FALSE,
  n_cpu = getOption("cartogram_n_cpu", "respect_future_plan"),
  show_progress = getOption("cartogram.show_progress", TRUE),
  animate = FALSE
)

\method{cartogram_cont}{SpatialPolygonsDataFrame}(
  x,
  weight,
  itermax = 15,
  maxSizeError = 1.0001,
  prepare = "adjust",
  threshold = "auto",
  verbose = FALSE,
  n_cpu = getOption("cartogram_n_cpu", "respect_future_plan"),
  show_progress = getOption("cartogram.show_progress", TRUE),
  animate = FALSE
)

\method{cartogram_cont}{sf}(
  x,
  weight,
  itermax = 15,
  maxSizeError = 1.0001,
  prepare = "adjust",
  threshold = "auto",
  verbose = FALSE,
  n_cpu = getOption("cartogram_n_cpu", "respect_future_plan"),
  show_progress = getOption("cartogram.show_progress", TRUE),
  animate = FALSE
)
}
\arguments{
\item{x}{a polygon or multiplogyon sf object}

\item{weight}{Name of the weighting variable in x}

\item{itermax}{Maximum iterations for the cartogram transformation, if maxSizeError ist not reached}

\item{maxSizeError}{Stop if meanSizeError is smaller than maxSizeError}

\item{prepare}{Weighting values are adjusted to reach convergence much earlier. Possible methods are 
"adjust", adjust values to restrict the mass vector to the quantiles defined by threshold and 1-threshold (default),
"remove", remove features with values lower than quantile at threshold,
"none", don't adjust weighting values}

\item{threshold}{"auto" or a threshold value between 0 and 1. With “auto”, the value is 0.05 or, if the proportion of zeros in the weight is greater than 0.05, the value is adjusted accordingly.}

\item{verbose}{print meanSizeError on each iteration}

\item{n_cpu}{Number of cores to use. Defaults to "respect_future_plan". Available options are:
* "respect_future_plan" - By default, the function will run on a single core, unless the user specifies the number of cores using \code{\link[future]{plan}} (e.g. `future::plan(future::multisession, workers = 4)`) before running the `cartogram_cont` function.
* "auto" - Use all except available cores (identified with \code{\link[parallelly]{availableCores}}) except 1, to keep the system responsive.
* a `numeric` value - Use the specified number of cores. In this case `cartogram_cont` will use set the specified number of cores internally with `future::plan(future::multisession, workers = n_cpu)` and revert that back by switching the plan back to whichever plan might have been set before by the user. If only 1 core is set, the function will not require `future` and `future.apply` and will run on a single core.}

\item{show_progress}{A `logical` value. If TRUE, show progress bar. Defaults to TRUE.}

\item{animate}{A `logical` value. If TRUE, save geometry distortion for each itertion and add a column .cartogram_iteration.}
}
\value{
An object of the same class as x
}
\description{
Construct a continuous area cartogram by a rubber sheet distortion algorithm (Dougenik et al. 1985)
}
\examples{
# ========= Basic example =========
library(sf)
library(cartogram)

nc = st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)

# transform to NAD83 / UTM zone 16N
nc_utm <- st_transform(nc, 26916)

# Create cartogram
nc_utm_carto <- cartogram_cont(nc_utm, weight = "BIR74", itermax = 5)

# Plot 
par(mfrow=c(2,1))
plot(nc[,"BIR74"], main="original", key.pos = NULL, reset = FALSE)
plot(nc_utm_carto[,"BIR74"], main="distorted", key.pos = NULL, reset = FALSE)


# ========= Advanced example 1 =========
# Faster cartogram using multiple CPU cores
# using n_cpu parameter
library(sf)
library(cartogram)

nc = st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)

# transform to NAD83 / UTM zone 16N
nc_utm <- st_transform(nc, 26916)

# Create cartogram using 2 CPU cores on local machine
nc_utm_carto <- cartogram_cont(nc_utm, weight = "BIR74", itermax = 5,
n_cpu = 2)

# Plot 
par(mfrow=c(2,1))
plot(nc[,"BIR74"], main="original", key.pos = NULL, reset = FALSE)
plot(nc_utm_carto[,"BIR74"], main="distorted", key.pos = NULL, reset = FALSE)


# ========= Advanced example 2 =========
# Faster cartogram using multiple CPU cores
# using future package plan
\donttest{
library(sf)
library(cartogram)
library(future)

nc = st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)

# transform to NAD83 / UTM zone 16N
nc_utm <- st_transform(nc, 26916)

# Set the future plan with 2 CPU local cores
# You can of course use any other plans, not just multisession
future::plan(future::multisession, workers = 2)

# Create cartogram with multiple CPU cores
# The cartogram_cont() will respect the plan set above
nc_utm_carto <- cartogram_cont(nc_utm, weight = "BIR74", itermax = 5)

# Shutdown the R processes that were created by the future plan
future::plan(future::sequential) 

# Plot 
par(mfrow=c(2,1))
plot(nc[,"BIR74"], main="original", key.pos = NULL, reset = FALSE)
plot(nc_utm_carto[,"BIR74"], main="distorted", key.pos = NULL, reset = FALSE)
}

# Animate distortion
nc_utm_carto <- cartogram_cont(nc_utm, weight = "BIR74", itermax = 5, animate = TRUE)

for (i in unique(nc_utm_carto$.cartogram_iteration)) {
Sys.sleep(0.3)
plot(nc_utm_carto[nc_utm_carto$.cartogram_iteration == i, "BIR74"]) 
}

}
\references{
Dougenik, J. A., Chrisman, N. R., & Niemeyer, D. R. (1985). An Algorithm To Construct Continuous Area Cartograms. In The Professional Geographer, 37(1), 75-81.
}
